---
title: "Relative Strength Index (RSI)"
description: "The Relative Strength Index is a momentum oscillator that measures the magnitude of recent price changes to evaluate overbought or oversold conditions in the price of an asset."
category: "momentum"
parameters:
  - name: "period"
    type: "number"
    default: 14
    min: 2
    max: 100
    description: "The number of periods used to calculate average gains and losses"
returns:
  type: "Vec<Option<f64>>"
  description: "A vector of RSI values ranging from 0 to 100. Returns None for periods with insufficient data"
complexity: "O(n)"
implementationStatus: "complete"
seeAlso: ["stochastic", "cci", "williams_r", "mfi"]
references:
  - title: "New Concepts in Technical Trading Systems"
    url: "https://www.amazon.com/New-Concepts-Technical-Trading-Systems/dp/0894590278"
  - title: "RSI - Investopedia"
    url: "https://www.investopedia.com/terms/r/rsi.asp"
---

import { IndicatorLayout } from '../../../layouts/IndicatorLayout.astro';
import { CodeBlock } from '../../../components/ui/CodeBlock.astro';

<IndicatorLayout 
  indicatorId="rsi" 
  indicatorName={frontmatter.title}
  description={frontmatter.description}
  parameters={frontmatter.parameters}
>

## Overview {#overview}

The Relative Strength Index (RSI), developed by J. Welles Wilder Jr. in 1978, is one of the most popular momentum oscillators in technical analysis. It measures the speed and magnitude of price changes to evaluate whether an asset is overbought or oversold.

The RSI oscillates between 0 and 100, providing a normalized view of momentum that's easy to interpret across different assets and timeframes. Unlike many other indicators, RSI's bounded nature makes it particularly useful for identifying potential reversal points and divergences between price and momentum.

## Interpretation {#interpretation}

### Traditional Levels
- **Above 70**: Overbought condition (potential selling opportunity)
- **Below 30**: Oversold condition (potential buying opportunity)
- **50**: Centerline, separates bullish (above) from bearish (below) momentum

### Alternative Interpretations
- **Bull Market**: Use 40 as oversold and 80 as overbought
- **Bear Market**: Use 20 as oversold and 60 as overbought
- **Strong Trends**: RSI can remain overbought/oversold for extended periods

### Divergences
- **Bullish Divergence**: Price makes new low, RSI makes higher low
- **Bearish Divergence**: Price makes new high, RSI makes lower high
- **Hidden Divergence**: Confirms trend continuation

### Failure Swings
- **Bullish Failure Swing**: RSI breaks above 30, pulls back above 30, then breaks previous high
- **Bearish Failure Swing**: RSI breaks below 70, rallies below 70, then breaks previous low

## Calculation {#calculation}

RSI uses a two-step calculation process:

```
1. Calculate Average Gain and Average Loss over the period
   Average Gain = Sum of Gains over period / period
   Average Loss = Sum of Losses over period / period

2. Calculate Relative Strength (RS)
   RS = Average Gain / Average Loss

3. Calculate RSI
   RSI = 100 - (100 / (1 + RS))
   
   Alternative formula:
   RSI = 100 * (Average Gain / (Average Gain + Average Loss))
```

Smoothing method (after initial calculation):
```
Average Gain = ((Previous Avg Gain × (period - 1)) + Current Gain) / period
Average Loss = ((Previous Avg Loss × (period - 1)) + Current Loss) / period
```

## Parameters {#parameters}

### period (default: 14)
The lookback period for calculating average gains and losses:

- **Original (14)**: Wilder's recommendation, widely used
- **Shorter (5-9)**: More sensitive, more signals, more noise
- **Standard (14)**: Balanced approach
- **Longer (21-25)**: Smoother, fewer but more reliable signals

Common period choices:
- **5**: Very short-term, day trading
- **9**: Short-term trading
- **14**: Standard, all-purpose
- **21**: Medium-term trading
- **25**: Longer-term perspective

## Returns & Output {#returns}

The RSI function returns:
- Values bounded between 0 and 100
- `None` for the first `period` values (insufficient data)
- Subsequent values as `Some(f64)`

Special cases:
- All gains, no losses: RSI approaches 100
- All losses, no gains: RSI approaches 0
- No price change: RSI stays at 50

## Example Usage {#usage}

### Basic RSI Calculation

<CodeBlock lang="rust">
use vectorta::indicators::rsi;

// Price data
let prices = vec![
    44.34, 44.09, 44.15, 43.61, 44.33, 44.83, 45.10, 45.42,
    45.84, 46.08, 45.89, 46.03, 45.61, 46.28, 46.28, 46.00
];

// Calculate 14-period RSI
let rsi_values = rsi(&prices, 14)?;

// First 14 values will be None
for (i, value) in rsi_values.iter().enumerate() {
    match value {
        Some(rsi) => println!("Day {}: RSI = {:.2}", i + 1, rsi),
        None => println!("Day {}: Insufficient data", i + 1),
    }
}
</CodeBlock>

### RSI-Based Trading Strategy

<CodeBlock lang="rust">
use vectorta::indicators::rsi;

struct RSIStrategy {
    oversold_level: f64,
    overbought_level: f64,
    period: usize,
}

impl RSIStrategy {
    fn new() -> Self {
        RSIStrategy {
            oversold_level: 30.0,
            overbought_level: 70.0,
            period: 14,
        }
    }
    
    fn generate_signals(&self, prices: &[f64]) -> Vec<Signal> {
        let rsi_values = rsi(prices, self.period).unwrap();
        let mut signals = Vec::new();
        let mut position = Position::Flat;
        
        for i in 1..rsi_values.len() {
            if let (Some(prev_rsi), Some(curr_rsi)) = (rsi_values[i-1], rsi_values[i]) {
                match position {
                    Position::Flat => {
                        // Enter long when RSI crosses above oversold
                        if prev_rsi <= self.oversold_level && curr_rsi > self.oversold_level {
                            signals.push(Signal::Buy(i, "RSI oversold bounce".to_string()));
                            position = Position::Long;
                        }
                        // Enter short when RSI crosses below overbought
                        else if prev_rsi >= self.overbought_level && curr_rsi < self.overbought_level {
                            signals.push(Signal::Sell(i, "RSI overbought reversal".to_string()));
                            position = Position::Short;
                        }
                    },
                    Position::Long => {
                        // Exit long when RSI becomes overbought
                        if curr_rsi > self.overbought_level {
                            signals.push(Signal::Exit(i, "RSI overbought exit".to_string()));
                            position = Position::Flat;
                        }
                    },
                    Position::Short => {
                        // Exit short when RSI becomes oversold
                        if curr_rsi < self.oversold_level {
                            signals.push(Signal::Cover(i, "RSI oversold exit".to_string()));
                            position = Position::Flat;
                        }
                    }
                }
            }
        }
        
        signals
    }
}
</CodeBlock>

### RSI Divergence Detection

<CodeBlock lang="rust">
use vectorta::indicators::rsi;

fn detect_divergences(prices: &[f64], rsi_period: usize, lookback: usize) -> Vec<Divergence> {
    let rsi_values = rsi(prices, rsi_period).unwrap();
    let mut divergences = Vec::new();
    
    for i in lookback..prices.len() {
        if let Some(current_rsi) = rsi_values[i] {
            // Find local peaks and troughs
            if let (Some(price_peak1), Some(price_peak2), Some(rsi_peak1), Some(rsi_peak2)) = 
                find_peaks(&prices[i-lookback..=i], &rsi_values[i-lookback..=i]) {
                
                // Bearish divergence: higher price high, lower RSI high
                if price_peak2 > price_peak1 && rsi_peak2 < rsi_peak1 {
                    divergences.push(Divergence::Bearish(i));
                }
            }
            
            if let (Some(price_trough1), Some(price_trough2), Some(rsi_trough1), Some(rsi_trough2)) = 
                find_troughs(&prices[i-lookback..=i], &rsi_values[i-lookback..=i]) {
                
                // Bullish divergence: lower price low, higher RSI low
                if price_trough2 < price_trough1 && rsi_trough2 > rsi_trough1 {
                    divergences.push(Divergence::Bullish(i));
                }
            }
        }
    }
    
    divergences
}
</CodeBlock>

### Multi-Timeframe RSI

<CodeBlock lang="rust">
use vectorta::indicators::rsi;

struct MultiTimeframeRSI {
    fast_rsi: Vec<Option<f64>>,
    medium_rsi: Vec<Option<f64>>,
    slow_rsi: Vec<Option<f64>>,
}

fn calculate_mtf_rsi(prices: &[f64]) -> MultiTimeframeRSI {
    MultiTimeframeRSI {
        fast_rsi: rsi(prices, 5).unwrap(),
        medium_rsi: rsi(prices, 14).unwrap(),
        slow_rsi: rsi(prices, 21).unwrap(),
    }
}

fn get_rsi_signal_strength(mtf: &MultiTimeframeRSI, index: usize) -> SignalStrength {
    match (mtf.fast_rsi[index], mtf.medium_rsi[index], mtf.slow_rsi[index]) {
        (Some(fast), Some(medium), Some(slow)) => {
            // All oversold
            if fast < 30.0 && medium < 30.0 && slow < 30.0 {
                SignalStrength::StrongBuy
            }
            // All overbought
            else if fast > 70.0 && medium > 70.0 && slow > 70.0 {
                SignalStrength::StrongSell
            }
            // Mixed signals
            else if (fast > 70.0 && medium > 60.0) || (medium > 70.0 && slow > 60.0) {
                SignalStrength::WeakSell
            }
            else if (fast < 30.0 && medium < 40.0) || (medium < 30.0 && slow < 40.0) {
                SignalStrength::WeakBuy
            }
            else {
                SignalStrength::Neutral
            }
        },
        _ => SignalStrength::Unknown
    }
}
</CodeBlock>

### RSI with Smoothing

<CodeBlock lang="rust">
use vectorta::indicators::{rsi, ema};

fn calculate_smoothed_rsi(prices: &[f64], rsi_period: usize, smooth_period: usize) 
    -> Result<Vec<Option<f64>>, Error> {
    
    // Calculate standard RSI
    let rsi_values = rsi(prices, rsi_period)?;
    
    // Extract non-None values for smoothing
    let valid_rsi: Vec<f64> = rsi_values.iter()
        .filter_map(|&x| x)
        .collect();
    
    // Apply EMA smoothing
    let smoothed = ema(&valid_rsi, smooth_period)?;
    
    // Reconstruct with original None positions
    let mut result = vec![None; rsi_values.len()];
    let mut smooth_idx = 0;
    
    for (i, &rsi_val) in rsi_values.iter().enumerate() {
        if rsi_val.is_some() && smooth_idx < smoothed.len() {
            result[i] = smoothed[smooth_idx];
            smooth_idx += 1;
        }
    }
    
    Ok(result)
}
</CodeBlock>

## Common Use Cases {#use-cases}

### 1. Overbought/Oversold Trading
Classic mean reversion strategy:
- Buy when RSI crosses above 30 from below
- Sell when RSI crosses below 70 from above
- Use stops and proper position sizing

### 2. Trend Confirmation
RSI can confirm trend strength:
- Uptrend: RSI mostly stays above 40, peaks above 70
- Downtrend: RSI mostly stays below 60, troughs below 30
- Strong trend: RSI remains in overbought/oversold territory

### 3. Divergence Trading
Most reliable RSI signals come from divergences:
- Regular divergence: Potential reversal
- Hidden divergence: Trend continuation
- Multiple divergences: Stronger signal

### 4. Support and Resistance
RSI itself can have support/resistance levels:
```rust
fn find_rsi_levels(rsi_values: &[Option<f64>], min_touches: usize) -> Vec<f64> {
    // Identify levels where RSI repeatedly bounces
    let mut level_counts: HashMap<i32, usize> = HashMap::new();
    
    for &rsi in rsi_values.iter().filter_map(|x| x.as_ref()) {
        let level = (*rsi as i32 / 5) * 5; // Round to nearest 5
        *level_counts.entry(level).or_insert(0) += 1;
    }
    
    level_counts.into_iter()
        .filter(|(_, count)| *count >= min_touches)
        .map(|(level, _)| level as f64)
        .collect()
}
```

### 5. Failure Swings
Wilder's preferred method:
```rust
fn detect_failure_swing(rsi_values: &[Option<f64>], is_bullish: bool) -> Option<usize> {
    let threshold = if is_bullish { 30.0 } else { 70.0 };
    
    // Implementation would detect the pattern described in Wilder's book
    // This is a simplified version
    None
}
```

## Edge Cases & Errors {#edge-cases}

### All Gains or All Losses
```rust
// When all price changes are positive
let rising_prices = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0];
let rsi_result = rsi(&rising_prices, 5)?;
// RSI will approach 100

// When all price changes are negative
let falling_prices = vec![8.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0, 1.0];
let rsi_result = rsi(&falling_prices, 5)?;
// RSI will approach 0
```

### No Price Change
```rust
let flat_prices = vec![50.0; 20];
let rsi_result = rsi(&flat_prices, 14)?;
// RSI will be exactly 50 after initial period
```

### Different Smoothing Methods
Different implementations may use slightly different smoothing:
```rust
// Wilder's smoothing (original)
avg_gain = (prev_avg_gain * (period - 1) + current_gain) / period

// Simple moving average (alternative)
avg_gain = sum_of_gains / period

// Exponential smoothing (alternative)
avg_gain = current_gain * alpha + prev_avg_gain * (1 - alpha)
```

### Period Larger Than Data
```rust
let small_data = vec![1.0, 2.0, 3.0, 4.0, 5.0];
let result = rsi(&small_data, 14)?;
// All values will be None
```

### Precision and Rounding
```rust
// Financial applications may need specific precision
fn calculate_precise_rsi(prices: &[f64], period: usize) -> Vec<Option<f64>> {
    // Use Decimal type or higher precision arithmetic
    // Round final RSI values to 2 decimal places
    rsi_values.iter().map(|&val| {
        val.map(|v| (v * 100.0).round() / 100.0)
    }).collect()
}
```

## References {#references}

1. **Wilder, J. Welles Jr.** (1978). *New Concepts in Technical Trading Systems*. Trend Research.

2. **Constance Brown** (1999). *Technical Analysis for the Trading Professional*. McGraw-Hill. 
   - Advanced RSI techniques and alternative interpretations

3. **Andrew Cardwell** (1998). *RSI: The Complete Guide*. Traders Press.
   - Positive and negative reversals, trend analysis with RSI

4. **John Hayden** (2004). *RSI: The Complete Guide*. Marketplace Books.
   - Modern applications and strategies

</IndicatorLayout>