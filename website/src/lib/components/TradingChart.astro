---
export interface Props {
	indicatorId: string;
	parameters: Array<{
		name: string;
		type: string;
		default: any;
		description: string;
	}>;
}

const { indicatorId, parameters } = Astro.props;
---

<div class="trading-chart-container">
	<div class="chart-header">
		<div class="chart-title">
			<h3>{indicatorId.toUpperCase()} Analysis</h3>
			<div class="chart-status">
				<span class="status-indicator" id="status-indicator">‚óè</span>
				<span class="status-text" id="status-text">Loading...</span>
			</div>
		</div>
		<div class="chart-controls">
			{parameters.map((param) => (
				<div class="control-group">
					<label for={`param-${param.name}`}>{param.name}:</label>
					<input 
						type="number" 
						id={`param-${param.name}`}
						data-param-name={param.name}
						value={param.default}
						min="1"
						max={param.name === 'period' ? 100 : (param.type === 'number' ? 10 : 1)}
						step={param.type === 'number' && param.default < 1 ? 0.01 : 1}
						class="param-input"
					/>
				</div>
			))}
			<button id="update-chart-btn" class="btn btn-primary">
				<span class="btn-text">Update Chart</span>
				<span class="btn-loading" style="display: none;">
					<svg class="spinner" width="16" height="16" viewBox="0 0 24 24">
						<circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" fill="none" stroke-dasharray="32" stroke-dashoffset="32">
							<animate attributeName="stroke-dashoffset" values="32;0" dur="1s" repeatCount="indefinite"/>
						</circle>
					</svg>
				</span>
			</button>
		</div>
	</div>
	
	<div class="chart-wrapper">
		<div id="main-chart" class="main-chart"></div>
		<div id="indicator-chart" class="indicator-chart"></div>
	</div>
	
	<div class="chart-footer">
		<div class="chart-legend" id="chart-legend"></div>
		<div class="chart-info">
			<span class="data-points" id="data-points">Data points: 0</span>
			<span class="last-update" id="last-update">Last update: Never</span>
		</div>
	</div>
</div>

<script define:vars={{ indicatorId }} is:inline>
        import { createChart, LineStyle, CrosshairMode } from 'lightweight-charts';
	import { parseCsvData, convertToCandlestickData, convertToVolumeData, getIndicatorData } from '../chartData.ts';
	import { loadWasmModule, extractPriceArrays } from '../wasm.ts';

	class TradingChartManager {
		constructor(indicatorId) {
			this.indicatorId = indicatorId;
			this.mainChart = null;
			this.indicatorChart = null;
			this.candlestickSeries = null;
			this.volumeSeries = null;
			this.indicatorSeries = [];
			this.rawData = [];
			this.wasmModule = null;
			this.isLoading = false;
			
			this.init();
		}

		async init() {
			try {
				this.updateStatus('loading', 'Initializing charts...');
                                this.setupCharts();
				await this.loadData();
				await this.loadWasm();
				this.setupEventListeners();
				this.updateStatus('success', 'Charts ready');
			} catch (error) {
				console.error('Chart initialization failed:', error);
				this.updateStatus('error', 'Failed to initialize charts');
			}
		}

		setupCharts() {
			const mainChartElement = document.getElementById('main-chart');
			const indicatorChartElement = document.getElementById('indicator-chart');

			// Main chart configuration
			this.mainChart = createChart(mainChartElement, {
				width: mainChartElement.clientWidth,
				height: 400,
				layout: {
					backgroundColor: '#ffffff',
					textColor: '#333333',
					fontSize: 12,
					fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
				},
				grid: {
					vertLines: { color: '#f0f0f0' },
					horzLines: { color: '#f0f0f0' }
				},
				crosshair: {
					mode: CrosshairMode.Normal,
					vertLine: { color: '#758696', width: 1, style: LineStyle.Dashed },
					horzLine: { color: '#758696', width: 1, style: LineStyle.Dashed }
				},
				rightPriceScale: {
					borderColor: '#d6dcde',
					scaleMargins: { top: 0.1, bottom: 0.1 }
				},
				timeScale: {
					borderColor: '#d6dcde',
					timeVisible: true,
					secondsVisible: false
				}
			});

			// Indicator chart configuration
			this.indicatorChart = createChart(indicatorChartElement, {
				width: indicatorChartElement.clientWidth,
				height: 200,
				layout: {
					backgroundColor: '#ffffff',
					textColor: '#333333',
					fontSize: 12,
					fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
				},
				grid: {
					vertLines: { color: '#f0f0f0' },
					horzLines: { color: '#f0f0f0' }
				},
				crosshair: {
					mode: CrosshairMode.Normal,
					vertLine: { color: '#758696', width: 1, style: LineStyle.Dashed },
					horzLine: { color: '#758696', width: 1, style: LineStyle.Dashed }
				},
				rightPriceScale: {
					borderColor: '#d6dcde',
					scaleMargins: { top: 0.15, bottom: 0.15 }
				},
				timeScale: {
					borderColor: '#d6dcde',
					timeVisible: true,
					secondsVisible: false
				}
			});

			// Handle resize
			window.addEventListener('resize', () => this.handleResize());
		}

		async loadData() {
			this.updateStatus('loading', 'Loading market data...');
			try {
				this.rawData = await parseCsvData();
				const candlestickData = convertToCandlestickData(this.rawData);
				const volumeData = convertToVolumeData(this.rawData);

				// Add candlestick series
				this.candlestickSeries = this.mainChart.addCandlestickSeries({
					upColor: '#26a69a',
					downColor: '#ef5350',
					borderVisible: false,
					wickUpColor: '#26a69a',
					wickDownColor: '#ef5350'
				});

				// Add volume series
				this.volumeSeries = this.mainChart.addHistogramSeries({
					priceFormat: { type: 'volume' },
					priceScaleId: 'volume',
					scaleMargins: { top: 0.8, bottom: 0 }
				});

				// Set data
				this.candlestickSeries.setData(candlestickData);
				this.volumeSeries.setData(volumeData);

				// Update data points counter
				document.getElementById('data-points').textContent = `Data points: ${this.rawData.length}`;
				
				// Load initial indicator
				await this.updateIndicator();
			} catch (error) {
				console.error('Data loading failed:', error);
				this.updateStatus('error', 'Failed to load data');
			}
		}

		async loadWasm() {
			try {
				this.updateStatus('loading', 'Loading WASM module...');
				this.wasmModule = await loadWasmModule();
				if (this.wasmModule) {
					this.updateStatus('success', 'WASM module loaded');
				} else {
					this.updateStatus('warning', 'Using fallback calculations');
				}
			} catch (error) {
				console.error('WASM loading failed:', error);
				this.updateStatus('warning', 'Using fallback calculations');
			}
		}

		async updateIndicator() {
			if (this.isLoading || !this.rawData.length) return;

			this.isLoading = true;
			this.updateStatus('loading', 'Calculating indicator...');

			try {
				// Clear existing indicator series
				this.indicatorSeries.forEach(series => {
					this.indicatorChart.removeSeries(series.series);
				});
				this.indicatorSeries = [];

				// Get parameters from inputs
				const params = this.getParameterValues();

				let indicatorData;
				
				// Use WASM if available, otherwise fallback to JavaScript
				if (this.wasmModule && this.wasmModule[`calculate_${this.indicatorId}`]) {
					indicatorData = await this.calculateWithWasm(params);
				} else {
					indicatorData = getIndicatorData(this.indicatorId, this.rawData);
				}

				// Add indicator series
				this.addIndicatorSeries(indicatorData);

				// Update legend
				this.updateLegend(indicatorData);

				// Update last update time
				document.getElementById('last-update').textContent = 
					`Last update: ${new Date().toLocaleTimeString()}`;

				this.updateStatus('success', 'Indicator updated');
			} catch (error) {
				console.error('Indicator calculation failed:', error);
				this.updateStatus('error', 'Calculation failed');
			} finally {
				this.isLoading = false;
			}
		}

		async calculateWithWasm(params) {
			const priceArrays = extractPriceArrays(this.rawData);
			const wasmFunction = this.wasmModule[`calculate_${this.indicatorId}`];

			let result;
			
			switch (this.indicatorId) {
				case 'rsi':
					result = wasmFunction(priceArrays.close, params.period || 14);
					return [{
						name: `RSI (${params.period || 14})`,
						data: this.convertWasmResult(result),
						color: '#9C27B0',
						lineWidth: 2
					}];

				case 'sma':
					result = wasmFunction(priceArrays.close, params.period || 20);
					return [{
						name: `SMA (${params.period || 20})`,
						data: this.convertWasmResult(result),
						color: '#2962FF',
						lineWidth: 2
					}];

				case 'ema':
					result = wasmFunction(priceArrays.close, params.period || 20);
					return [{
						name: `EMA (${params.period || 20})`,
						data: this.convertWasmResult(result),
						color: '#FF6D00',
						lineWidth: 2
					}];

				case 'macd':
					result = wasmFunction(
						priceArrays.close, 
						params.fast_period || 12, 
						params.slow_period || 26, 
						params.signal_period || 9
					);
					return [
						{
							name: 'MACD',
							data: this.convertWasmResult(result.macd),
							color: '#00E676',
							lineWidth: 2
						},
						{
							name: 'Signal',
							data: this.convertWasmResult(result.signal),
							color: '#FF1744',
							lineWidth: 2
						}
					];

				case 'bollinger_bands':
					result = wasmFunction(
						priceArrays.close, 
						params.period || 20, 
						params.std_dev || 2
					);
					return [
						{
							name: 'BB Upper',
							data: this.convertWasmResult(result.upper),
							color: '#FF5722',
							lineWidth: 1
						},
						{
							name: 'BB Middle',
							data: this.convertWasmResult(result.middle),
							color: '#607D8B',
							lineWidth: 2
						},
						{
							name: 'BB Lower',
							data: this.convertWasmResult(result.lower),
							color: '#FF5722',
							lineWidth: 1
						}
					];

				case 'atr':
					result = wasmFunction(
						priceArrays.high, 
						priceArrays.low, 
						priceArrays.close, 
						params.period || 14
					);
					return [{
						name: `ATR (${params.period || 14})`,
						data: this.convertWasmResult(result),
						color: '#795548',
						lineWidth: 2
					}];

				default:
					throw new Error(`WASM function not implemented for ${this.indicatorId}`);
			}
		}

		convertWasmResult(wasmArray) {
			const result = [];
			for (let i = 0; i < wasmArray.length; i++) {
				if (wasmArray[i] !== 0) { // Skip zero values (usually initial periods)
					result.push({
						time: (this.rawData[i].timestamp / 1000),
						value: wasmArray[i]
					});
				}
			}
			return result;
		}

		addIndicatorSeries(indicatorData) {
			indicatorData.forEach(indicator => {
				const seriesOptions = {
					color: indicator.color,
					lineWidth: indicator.lineWidth || 2,
					lineStyle: indicator.lineStyle || LineStyle.Solid,
					priceScaleId: indicator.priceScaleId || 'right'
				};

				// Determine which chart to use
				const chart = this.shouldUseMainChart(this.indicatorId) ? this.mainChart : this.indicatorChart;
				const series = chart.addLineSeries(seriesOptions);
				series.setData(indicator.data);

				this.indicatorSeries.push({
					series,
					name: indicator.name,
					color: indicator.color
				});
			});
		}

		shouldUseMainChart(indicatorId) {
			// These indicators should be overlaid on the main price chart
			const overlayIndicators = ['sma', 'ema', 'wma', 'bollinger_bands', 'keltner', 'donchian'];
			return overlayIndicators.includes(indicatorId);
		}

		getParameterValues() {
			const params = {};
			const inputs = document.querySelectorAll('.param-input');
			inputs.forEach(input => {
				const paramName = input.dataset.paramName;
				params[paramName] = parseFloat(input.value) || input.value;
			});
			return params;
		}

		setupEventListeners() {
			document.getElementById('update-chart-btn').addEventListener('click', () => {
				this.updateIndicator();
			});

			// Auto-update on parameter change (debounced)
			let updateTimeout;
			document.querySelectorAll('.param-input').forEach(input => {
				input.addEventListener('input', () => {
					clearTimeout(updateTimeout);
					updateTimeout = setTimeout(() => this.updateIndicator(), 500);
				});
			});
		}

		updateStatus(type, message) {
			const indicator = document.getElementById('status-indicator');
			const text = document.getElementById('status-text');
			
			indicator.className = `status-indicator ${type}`;
			text.textContent = message;
		}

		updateLegend(indicatorData) {
			const legend = document.getElementById('chart-legend');
			legend.innerHTML = '';
			
			indicatorData.forEach(indicator => {
				const legendItem = document.createElement('span');
				legendItem.className = 'legend-item';
				legendItem.innerHTML = `
					<span class="legend-color" style="background-color: ${indicator.color}"></span>
					<span class="legend-name">${indicator.name}</span>
				`;
				legend.appendChild(legendItem);
			});
		}

		handleResize() {
			if (this.mainChart && this.indicatorChart) {
				const mainChartElement = document.getElementById('main-chart');
				const indicatorChartElement = document.getElementById('indicator-chart');
				
				this.mainChart.applyOptions({ 
					width: mainChartElement.clientWidth 
				});
				this.indicatorChart.applyOptions({ 
					width: indicatorChartElement.clientWidth 
				});
			}
		}
	}

	// Initialize chart when DOM is ready
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', () => {
			new TradingChartManager(indicatorId);
		});
	} else {
		new TradingChartManager(indicatorId);
	}
</script>

<style>
	.trading-chart-container {
		background: white;
		border-radius: 12px;
		box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
		overflow: hidden;
		margin: 2rem 0;
	}

	.chart-header {
		background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
		color: white;
		padding: 1.5rem;
		display: flex;
		justify-content: space-between;
		align-items: center;
		flex-wrap: wrap;
		gap: 1rem;
	}

	.chart-title {
		display: flex;
		align-items: center;
		gap: 1rem;
	}

	.chart-title h3 {
		margin: 0;
		font-size: 1.4rem;
		font-weight: 600;
	}

	.chart-status {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		font-size: 0.9rem;
	}

	.status-indicator {
		font-size: 1.2rem;
		transition: color 0.3s ease;
	}

	.status-indicator.loading { color: #FFC107; }
	.status-indicator.success { color: #4CAF50; }
	.status-indicator.error { color: #F44336; }
	.status-indicator.warning { color: #FF9800; }

	.chart-controls {
		display: flex;
		gap: 1rem;
		align-items: end;
		flex-wrap: wrap;
	}

	.control-group {
		display: flex;
		flex-direction: column;
		gap: 0.25rem;
	}

	.control-group label {
		font-size: 0.85rem;
		font-weight: 500;
		opacity: 0.9;
	}

	.param-input {
		padding: 0.5rem;
		border: 1px solid rgba(255, 255, 255, 0.3);
		border-radius: 6px;
		background: rgba(255, 255, 255, 0.1);
		color: white;
		width: 80px;
		font-size: 0.9rem;
		backdrop-filter: blur(10px);
	}

	.param-input::placeholder {
		color: rgba(255, 255, 255, 0.6);
	}

	.param-input:focus {
		outline: none;
		border-color: rgba(255, 255, 255, 0.5);
		background: rgba(255, 255, 255, 0.15);
	}

	.btn {
		padding: 0.75rem 1.5rem;
		border: none;
		border-radius: 8px;
		cursor: pointer;
		font-weight: 600;
		transition: all 0.2s ease;
		display: flex;
		align-items: center;
		gap: 0.5rem;
		font-size: 0.9rem;
	}

	.btn-primary {
		background: rgba(255, 255, 255, 0.2);
		color: white;
		border: 1px solid rgba(255, 255, 255, 0.3);
		backdrop-filter: blur(10px);
	}

	.btn-primary:hover {
		background: rgba(255, 255, 255, 0.3);
		transform: translateY(-1px);
	}

	.btn-primary:active {
		transform: translateY(0);
	}

	.spinner {
		animation: spin 1s linear infinite;
	}

	@keyframes spin {
		from { transform: rotate(0deg); }
		to { transform: rotate(360deg); }
	}

	.chart-wrapper {
		background: #fafafa;
		padding: 1rem;
	}

	.main-chart, .indicator-chart {
		margin-bottom: 1rem;
		border-radius: 8px;
		overflow: hidden;
		box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
	}

	.chart-footer {
		background: #f8f9fa;
		padding: 1rem 1.5rem;
		display: flex;
		justify-content: space-between;
		align-items: center;
		flex-wrap: wrap;
		gap: 1rem;
		border-top: 1px solid #e9ecef;
	}

	.chart-legend {
		display: flex;
		gap: 1.5rem;
		flex-wrap: wrap;
	}

	.legend-item {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		font-size: 0.9rem;
		color: #495057;
	}

	.legend-color {
		width: 16px;
		height: 3px;
		border-radius: 2px;
	}

	.chart-info {
		display: flex;
		gap: 1rem;
		font-size: 0.85rem;
		color: #6c757d;
	}

	@media (max-width: 768px) {
		.chart-header {
			flex-direction: column;
			align-items: stretch;
		}

		.chart-controls {
			justify-content: center;
		}

		.chart-footer {
			flex-direction: column;
			align-items: stretch;
		}

		.chart-info {
			justify-content: center;
		}
	}
</style>