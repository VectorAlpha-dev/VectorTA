---
import IndicatorLayout from '../../layouts/IndicatorLayout.astro';

const indicatorId = 'ht_trendline';
const indicatorName = 'Hilbert Transform - Instantaneous Trendline';
const description = `The Hilbert Transform Instantaneous Trendline is a smooth, adaptive moving average that uses the dominant cycle period to create a trend-following line with minimal lag, automatically adjusting to market conditions without whipsaws.`;
const parameters = [];  // Hilbert Transform indicators are typically parameter-free
---

<IndicatorLayout
  indicatorId={indicatorId}
  indicatorName={indicatorName}
  description={description}
  parameters={parameters}
>
  <h2 id="overview">Overview</h2>
  <p>
    The Hilbert Transform - Instantaneous Trendline, developed by John Ehlers, represents a 
    revolutionary approach to creating adaptive moving averages. Unlike traditional moving averages 
    that use fixed periods, the Instantaneous Trendline automatically adjusts its smoothing based 
    on the measured dominant cycle period in the market. This creates a trend-following indicator 
    that remains smooth during trends but becomes more responsive during cycle mode.
  </p>
  <p>
    The "instantaneous" aspect refers to the indicator's ability to adapt in real-time to changing 
    market conditions. When the dominant cycle period is long (trending market), the trendline 
    becomes smoother with more lag. When the cycle period is short (cycling market), it becomes 
    more responsive. This adaptive behavior makes it superior to fixed-period moving averages for 
    both trend following and cycle identification.
  </p>

  <h2 id="interpretation">Interpretation</h2>
  <h3>Trend Identification</h3>
  <ul>
    <li><strong>Price above trendline:</strong> Bullish trend bias</li>
    <li><strong>Price below trendline:</strong> Bearish trend bias</li>
    <li><strong>Slope direction:</strong> Primary trend direction</li>
    <li><strong>Slope steepness:</strong> Trend strength indicator</li>
  </ul>

  <h3>Trading Signals</h3>
  <ul>
    <li><strong>Crossover signals:</strong> Price crossing trendline suggests trend change</li>
    <li><strong>Trendline turns:</strong> Changes in trendline direction signal momentum shifts</li>
    <li><strong>Support/Resistance:</strong> Trendline acts as dynamic support in uptrends</li>
    <li><strong>Pullback entries:</strong> Buy/sell when price touches trendline in trends</li>
  </ul>

  <h3>Key Characteristics</h3>
  <ul>
    <li><strong>Adaptive smoothing:</strong> Automatically adjusts to market conditions</li>
    <li><strong>Minimal whipsaws:</strong> Smooth during trends, responsive during cycles</li>
    <li><strong>No lag in cycles:</strong> Becomes more responsive when cycling detected</li>
    <li><strong>Trend persistence:</strong> Maintains direction during strong trends</li>
  </ul>

  <h2 id="calculation">Calculation</h2>
  <p>The Instantaneous Trendline calculation involves:</p>
  <ol>
    <li><strong>Measure Dominant Cycle Period:</strong> Using Hilbert Transform</li>
    <li><strong>Calculate Adaptive Alpha:</strong> <code>α = 2 / (Period + 1)</code></li>
    <li><strong>Apply Adaptive EMA:</strong> <code>IT[i] = α * Price[i] + (1 - α) * IT[i-1]</code></li>
    <li><strong>Smooth the Alpha:</strong> Prevent abrupt changes in smoothing factor</li>
    <li><strong>Apply Median Filter:</strong> Remove outliers from cycle period measurement</li>
    <li><strong>Secondary Smoothing:</strong> Additional 3-bar WMA for stability</li>
  </ol>
  <p>
    The key innovation is using the instantaneous cycle period to continuously adjust the smoothing 
    factor (alpha). This creates a moving average that knows when to be smooth (trending markets) 
    and when to be responsive (cycling markets), eliminating the need for manual period optimization.
  </p>

  <h2 id="parameters">Parameters</h2>
  <p>
    The Hilbert Transform Instantaneous Trendline has no user-adjustable parameters. The indicator 
    automatically determines the optimal smoothing based on the dominant cycle period measured by 
    the Hilbert Transform. This self-optimizing design ensures the trendline always uses the most 
    appropriate smoothing for current market conditions.
  </p>
  <p>
    Internal adaptive mechanisms:
  </p>
  <ul>
    <li><strong>Period range:</strong> Typically adapts between 10-50 bar equivalent</li>
    <li><strong>Alpha bounds:</strong> Smoothing factor limited to prevent instability</li>
    <li><strong>Median filter:</strong> 5-bar median of measured periods</li>
    <li><strong>Output smoothing:</strong> 3-bar WMA on final trendline</li>
  </ul>

  <h2 id="returns">Returns & Output</h2>
  <p>The indicator returns an adaptive trendline:</p>
  <ul>
    <li><strong>Type:</strong> Array of floating-point numbers</li>
    <li><strong>Values:</strong> Smoothed price levels following the trend</li>
    <li><strong>Characteristics:</strong> Smooth in trends, responsive in cycles</li>
    <li><strong>Lag:</strong> Variable, automatically minimized based on conditions</li>
    <li><strong>Initial values:</strong> Requires ~50 bars for Hilbert Transform</li>
  </ul>

  <h2 id="usage">Example Usage</h2>
  <h3>Rust Implementation</h3>
  <pre><code class="language-rust">
use ta_lib::indicators::{ht_trendline, ht_dcperiod, ht_trendmode};

// Calculate Instantaneous Trendline
let trendline = ht_trendline(&close_prices)?;

// Basic trend following signals
for i in 1..close_prices.len() {
    if let (Some(price), Some(trend), Some(prev_trend)) = 
        (close_prices.get(i), trendline.get(i), trendline.get(i-1)) {
        
        // Detect crossovers
        if close_prices[i-1] <= trendline[i-1] && price > trend {
            println!("Bullish crossover at bar {}: Price {:.2} crossed above {:.2}", 
                     i, price, trend);
        } else if close_prices[i-1] >= trendline[i-1] && price < trend {
            println!("Bearish crossover at bar {}: Price {:.2} crossed below {:.2}", 
                     i, price, trend);
        }
        
        // Measure trend strength
        let trend_slope = (trend - prev_trend) / prev_trend * 100.0;
        if trend_slope.abs() > 0.5 {
            let direction = if trend_slope > 0.0 { "up" } else { "down";
            println!("Strong trend {} at bar {}: {:.2}% slope", direction, i, trend_slope);
        }
        
        // Identify pullback opportunities
        let distance = (price - trend) / trend * 100.0;
        if distance.abs() < 0.5 && trend_slope > 0.2 {
            println!("Pullback buy opportunity at bar {}: Price near rising trendline", i);
        }
    }
}

// Combine with other HT indicators
let dc_period = ht_dcperiod(&close_prices)?;
let trend_mode = ht_trendmode(&close_prices)?;

for i in 50..close_prices.len() {
    if let (Some(trend), Some(period), Some(mode)) = 
        (trendline.get(i), dc_period.get(i), trend_mode.get(i)) {
        
        // Analyze trendline behavior
        println!("Bar {}: Trendline = {:.2}, Period = {:.1}, Mode = {}", 
                 i, trend, period, if *mode > 0.0 { "Trending" } else { "Cycling" });
        
        // Adaptive behavior analysis
        let effective_alpha = 2.0 / (period + 1.0);
        let equivalent_ema_period = (2.0 / effective_alpha) - 1.0;
        println!("  Adaptive smoothing equivalent to {:.1}-period EMA", equivalent_ema_period);
    }
}
  </code></pre>

  <h3>Python Integration</h3>
  <pre><code class="language-python">
import pandas as pd
import numpy as np
from ta_lib import ht_trendline, ht_dcperiod, ht_trendmode

# Calculate Instantaneous Trendline
df['trendline'] = ht_trendline(df['close'])

# Generate crossover signals
df['above_trend'] = df['close'] > df['trendline']
df['bullish_cross'] = df['above_trend'] & ~df['above_trend'].shift(1)
df['bearish_cross'] = ~df['above_trend'] & df['above_trend'].shift(1)

# Calculate trend slope
df['trend_slope'] = df['trendline'].pct_change() * 100
df['trend_direction'] = np.where(df['trend_slope'] > 0, 1, -1)

# Measure distance from trendline
df['distance_pct'] = (df['close'] - df['trendline']) / df['trendline'] * 100

# Identify pullback opportunities
df['pullback_buy'] = (
    (df['distance_pct'] > -1) & 
    (df['distance_pct'] < 0.5) & 
    (df['trend_slope'] > 0.1) &
    (df['trend_slope'].rolling(5).mean() > 0.1)
)

df['pullback_sell'] = (
    (df['distance_pct'] < 1) & 
    (df['distance_pct'] > -0.5) & 
    (df['trend_slope'] < -0.1) &
    (df['trend_slope'].rolling(5).mean() < -0.1)
)

# Combine with cycle analysis
df['dc_period'] = ht_dcperiod(df['close'])
df['trend_mode'] = ht_trendmode(df['close'])

# Analyze adaptive behavior
df['effective_alpha'] = 2 / (df['dc_period'] + 1)
df['ema_equivalent'] = (2 / df['effective_alpha']) - 1

print(f"Trendline adapts between {df['ema_equivalent'].min():.1f} and {df['ema_equivalent'].max():.1f} period EMA equivalent")
  </code></pre>

  <h2 id="use-cases">Common Use Cases</h2>
  <h3>1. Adaptive Trend Following</h3>
  <p>Trade with the trend using adaptive signals:</p>
  <pre><code class="language-python">
# Calculate indicators
trendline = ht_trendline(close)
trend_mode = ht_trendmode(close)

# Trend following rules
uptrend = close > trendline
downtrend = close < trendline

# Entry signals with trend mode filter
# Only take signals when in trending mode
trending_market = trend_mode > 0

buy_signal = uptrend & (close.shift(1) <= trendline.shift(1)) & trending_market
sell_signal = downtrend & (close.shift(1) >= trendline.shift(1)) & trending_market

# Trail stops using trendline
long_stop = trendline * 0.98  # 2% below trendline
short_stop = trendline * 1.02  # 2% above trendline

# Exit on trendline violation
exit_long = close < trendline
exit_short = close > trendline
  </code></pre>

  <h3>2. Mean Reversion from Trendline</h3>
  <p>Trade reversions to the adaptive trendline:</p>
  <pre><code class="language-python">
# Calculate distance from trendline
trendline = ht_trendline(close)
distance = (close - trendline) / trendline * 100

# Define extreme distances (adaptive based on volatility)
volatility = close.pct_change().rolling(20).std() * 100
upper_band = 2 * volatility
lower_band = -2 * volatility

# Mean reversion signals
oversold = distance < lower_band
overbought = distance > upper_band

# Confirm with trendline direction
trend_up = trendline > trendline.shift(1)
trend_down = trendline < trendline.shift(1)

# Trade signals
buy_reversion = oversold & trend_up  # Buy dips in uptrend
sell_reversion = overbought & trend_down  # Sell rallies in downtrend

# Target: Return to trendline
profit_target = trendline
  </code></pre>

  <h3>3. Multi-Timeframe Trend Analysis</h3>
  <p>Combine trendlines from multiple timeframes:</p>
  <pre><code class="language-python">
# Calculate trendlines on different timeframes
trendline_5m = ht_trendline(close_5m)
trendline_15m = ht_trendline(close_15m)
trendline_1h = ht_trendline(close_1h)

# Resample to align timeframes
trendline_15m_resampled = trendline_15m.reindex(close_5m.index, method='ffill')
trendline_1h_resampled = trendline_1h.reindex(close_5m.index, method='ffill')

# Trend alignment
all_up = (close_5m > trendline_5m) & \
         (close_5m > trendline_15m_resampled) & \
         (close_5m > trendline_1h_resampled)

all_down = (close_5m < trendline_5m) & \
           (close_5m < trendline_15m_resampled) & \
           (close_5m < trendline_1h_resampled)

# Trade only with full alignment
strong_buy = all_up & (close_5m.shift(1) <= trendline_5m.shift(1))
strong_sell = all_down & (close_5m.shift(1) >= trendline_5m.shift(1))

# Measure trend consistency
trend_score = (
    (close_5m > trendline_5m).astype(int) +
    (close_5m > trendline_15m_resampled).astype(int) +
    (close_5m > trendline_1h_resampled).astype(int)
) / 3
  </code></pre>

  <h2 id="edge-cases">Edge Cases & Errors</h2>
  <h3>Common Issues</h3>
  <ul>
    <li><strong>Initialization period:</strong> Requires ~50 bars for accurate adaptation</li>
    <li><strong>Extreme volatility:</strong> May become too responsive in very volatile conditions</li>
    <li><strong>Cycle measurement errors:</strong> Poor cycle detection affects smoothing</li>
    <li><strong>Transition periods:</strong> May lag during trend-to-cycle transitions</li>
  </ul>

  <h3>Best Practices</h3>
  <ul>
    <li>Allow adequate warmup period before trading signals</li>
    <li>Combine with HT_TRENDMODE for market regime confirmation</li>
    <li>Use volatility-adjusted bands around trendline</li>
    <li>Monitor effective smoothing period for insights</li>
    <li>Consider price action confirmation at trendline</li>
    <li>Be cautious during major news events</li>
  </ul>

  <h2 id="references">References</h2>
  <ul>
    <li>Ehlers, J. F. (2001). <em>Rocket Science for Traders</em>. John Wiley & Sons.</li>
    <li>Ehlers, J. F. (2013). <em>Cycle Analytics for Traders</em>. John Wiley & Sons.</li>
    <li>Adaptive moving average techniques and theory</li>
    <li>Comparison with KAMA, VIDYA, and other adaptive averages</li>
  </ul>
</IndicatorLayout>