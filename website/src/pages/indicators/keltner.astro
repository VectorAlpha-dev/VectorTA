---
import IndicatorLayout from '../../layouts/IndicatorLayout.astro';

const indicatorId = 'keltner';
const indicatorName = 'Keltner Channels';
const description = `Keltner Channels are volatility-based envelope indicators that create dynamic bands around an exponential moving average using Average True Range (ATR), helping identify overbought/oversold conditions, trend direction, and potential breakout opportunities.`;
const parameters = [
  {
    "name": "ema_period",
    "type": "number",
    "default": 20,
    "min": 5,
    "max": 200,
    "description": "EMA period for center line"
  },
  {
    "name": "atr_period",
    "type": "number",
    "default": 10,
    "min": 2,
    "max": 100,
    "description": "ATR period for volatility"
  },
  {
    "name": "multiplier",
    "type": "number",
    "default": 2.0,
    "min": 0.5,
    "max": 5.0,
    "description": "ATR multiplier for band width"
  }
];
---

<IndicatorLayout
  indicatorId={indicatorId}
  indicatorName={indicatorName}
  description={description}
  parameters={parameters}
>
  <h2 id="overview">Overview</h2>
  <p>
    Keltner Channels, developed by Chester Keltner and later modified by Linda Raschke, are 
    volatility-based envelope indicators that help traders identify trend direction, overbought/oversold 
    conditions, and potential breakout opportunities. The channels consist of an exponential moving 
    average (EMA) centerline with upper and lower bands set at a multiple of the Average True Range (ATR) 
    above and below the centerline.
  </p>
  <p>
    Unlike Bollinger Bands which use standard deviation, Keltner Channels use ATR for volatility 
    measurement, making them smoother and less prone to whipsaws. The channels expand and contract 
    based on market volatility, providing a dynamic framework for identifying trading opportunities. 
    Keltner Channels are particularly effective for trend-following strategies and can be used to 
    identify strong trends when prices consistently trade near or outside the bands.
  </p>

  <h2 id="interpretation">Interpretation</h2>
  <h3>Channel Components</h3>
  <ul>
    <li><strong>Center Line (EMA):</strong> The baseline showing trend direction</li>
    <li><strong>Upper Channel:</strong> EMA + (ATR × multiplier)</li>
    <li><strong>Lower Channel:</strong> EMA - (ATR × multiplier)</li>
    <li><strong>Channel Width:</strong> Reflects market volatility</li>
  </ul>

  <h3>Trading Signals</h3>
  <ul>
    <li><strong>Trend identification:</strong> Price above/below center line indicates trend</li>
    <li><strong>Channel breaks:</strong> Closes outside channels signal strong momentum</li>
    <li><strong>Mean reversion:</strong> Price returns to center line from extremes</li>
    <li><strong>Squeeze:</strong> Narrow channels indicate low volatility, potential breakout</li>
    <li><strong>Walk the bands:</strong> Strong trends "walk" along upper/lower channel</li>
  </ul>

  <h3>Market Conditions</h3>
  <ul>
    <li><strong>Trending markets:</strong> Price hugs one channel, uses other as stop</li>
    <li><strong>Ranging markets:</strong> Price oscillates between channels</li>
    <li><strong>Breakouts:</strong> Channel breaks with expanding width confirm moves</li>
    <li><strong>Consolidation:</strong> Narrowing channels indicate compression</li>
  </ul>

  <h2 id="calculation">Calculation</h2>
  <p>Keltner Channels calculation involves three steps:</p>
  <ol>
    <li><strong>Calculate Center Line:</strong>
      <ul>
        <li>Center Line = EMA(Close, ema_period)</li>
        <li>Typically using 20-period EMA</li>
      </ul>
    </li>
    <li><strong>Calculate Average True Range:</strong>
      <ul>
        <li>True Range = max(High-Low, abs(High-Previous Close), abs(Low-Previous Close))</li>
        <li>ATR = SMA(True Range, atr_period)</li>
      </ul>
    </li>
    <li><strong>Calculate Channel Bands:</strong>
      <ul>
        <li>Upper Channel = Center Line + (ATR × multiplier)</li>
        <li>Lower Channel = Center Line - (ATR × multiplier)</li>
      </ul>
    </li>
  </ol>
  <p>
    The original Keltner Channels used (High+Low+Close)/3 as the center line and (High-Low) for 
    volatility. The modern version using EMA and ATR, popularized by Linda Raschke, provides 
    better trend identification and more consistent volatility measurement across different market 
    conditions.
  </p>

  <h2 id="parameters">Parameters</h2>
  <ul>
    <li>
      <strong>EMA Period (default: 20):</strong> The period for the exponential moving average 
      center line. Common values are 10 (short-term), 20 (standard), and 50 (long-term). Shorter 
      periods make channels more responsive but increase whipsaws. Longer periods create smoother 
      channels better suited for position trading.
    </li>
    <li>
      <strong>ATR Period (default: 10):</strong> The period for calculating Average True Range. 
      Typically set to half the EMA period or 10 bars. Shorter ATR periods make bands more 
      responsive to volatility changes, while longer periods create more stable channel width. 
      Most traders use 10 regardless of EMA period.
    </li>
    <li>
      <strong>Multiplier (default: 2.0):</strong> The number of ATRs to add/subtract from the 
      center line. Common values are 1.5 (tight), 2.0 (standard), and 2.5-3.0 (wide). Lower 
      multipliers create more signals but more false breakouts. Higher multipliers reduce false 
      signals but may miss early moves.
    </li>
  </ul>

  <h2 id="returns">Returns & Output</h2>
  <p>The indicator returns three arrays representing the channel lines:</p>
  <ul>
    <li><strong>Upper Band:</strong> Array of upper channel values</li>
    <li><strong>Middle Band:</strong> Array of EMA center line values</li>
    <li><strong>Lower Band:</strong> Array of lower channel values</li>
    <li><strong>Initial values:</strong> First max(ema_period, atr_period) values may be unstable</li>
    <li><strong>Band relationship:</strong> Upper and lower equidistant from middle</li>
  </ul>

  <h2 id="usage">Example Usage</h2>
  <h3>Rust Implementation</h3>
  <pre><code class="language-rust">
use ta_lib::indicators::{keltner_channels, ema, atr};

// Price data
let high = vec![105.0, 106.0, 107.5, 106.5, 108.0, 109.0, 108.5, 110.0, 111.0, 110.5];
let low = vec![102.0, 103.0, 104.0, 103.5, 105.0, 106.0, 105.5, 107.0, 108.0, 107.5];
let close = vec![104.0, 105.0, 106.0, 105.5, 107.0, 108.0, 107.5, 109.0, 110.0, 109.5];

// Calculate Keltner Channels
let (upper_band, middle_band, lower_band) = keltner_channels(&high, &low, &close, 20, 10, 2.0)?;

// Trading logic
for i in 20..close.len() {
    if let (Some(upper), Some(middle), Some(lower)) = 
        (upper_band[i], middle_band[i], lower_band[i]) {
        
        // Channel position
        let price = close[i];
        let position = if price > upper {
            "Above upper channel"
        } else if price < lower {
            "Below lower channel"
        } else if price > middle {
            "Upper half"
        } else {
            "Lower half"
        };
        
        println!("Bar {}: Price={:.2}, Position: {}", i, price, position);
        
        // Channel width (volatility)
        let channel_width = upper - lower;
        let width_pct = channel_width / middle * 100.0;
        println!("  Channel width: {:.2} ({:.1}% of price)", channel_width, width_pct);
        
        // Breakout detection
        if i > 0 {
            let prev_close = close[i-1];
            if prev_close <= upper_band[i-1] && price > upper {
                println!("  BREAKOUT: Price broke above upper channel!");
            } else if prev_close >= lower_band[i-1] && price < lower {
                println!("  BREAKDOWN: Price broke below lower channel!");
            }
        }
        
        // Trend strength
        let trend_strength = (price - middle) / (upper - middle).max(middle - lower) * 100.0;
        println!("  Trend strength: {:.1}%", trend_strength);
    }
}

// Squeeze detection
fn detect_squeeze(upper: &[Option<f64>], lower: &[Option<f64>], lookback: usize) -> Vec<bool> {
    let mut squeeze = vec![false; upper.len()];
    
    for i in lookback..upper.len() {
        if let (Some(u), Some(l)) = (upper[i], lower[i]) {
            let current_width = u - l;
            
            // Calculate average width
            let mut sum_width = 0.0;
            let mut count = 0;
            for j in (i-lookback)..i {
                if let (Some(u_hist), Some(l_hist)) = (upper[j], lower[j]) {
                    sum_width += u_hist - l_hist;
                    count += 1;
                }
            }
            
            if count > 0 {
                let avg_width = sum_width / count as f64;
                squeeze[i] = current_width < avg_width * 0.75; // 75% of average
            }
        }
    }
    squeeze
}
  </code></pre>

  <h3>Python Integration</h3>
  <pre><code class="language-python">
import pandas as pd
import numpy as np
from ta_lib import keltner_channels, ema, atr

# Example price data
df = pd.DataFrame({
    'high': [105, 106, 107.5, 106.5, 108, 109, 108.5, 110, 111, 110.5, 112, 113, 112.5],
    'low': [102, 103, 104, 103.5, 105, 106, 105.5, 107, 108, 107.5, 109, 110, 109.5],
    'close': [104, 105, 106, 105.5, 107, 108, 107.5, 109, 110, 109.5, 111, 112, 111.5]
})

# Calculate Keltner Channels
upper, middle, lower = keltner_channels(
    df['high'], df['low'], df['close'], 
    ema_period=20, atr_period=10, multiplier=2.0
)
df['kc_upper'] = upper
df['kc_middle'] = middle
df['kc_lower'] = lower

# Channel position
df['above_upper'] = df['close'] > df['kc_upper']
df['below_lower'] = df['close'] < df['kc_lower']
df['above_middle'] = df['close'] > df['kc_middle']

# Channel width analysis
df['channel_width'] = df['kc_upper'] - df['kc_lower']
df['width_pct'] = df['channel_width'] / df['kc_middle'] * 100
df['width_expanding'] = df['channel_width'] > df['channel_width'].shift(1)

# Breakout signals
df['breakout_up'] = df['above_upper'] & ~df['above_upper'].shift(1)
df['breakout_down'] = df['below_lower'] & ~df['below_lower'].shift(1)

# Squeeze detection
df['squeeze'] = df['channel_width'] < df['channel_width'].rolling(20).mean() * 0.75
df['squeeze_release'] = ~df['squeeze'] & df['squeeze'].shift(1)

# Trend strength
df['trend_strength'] = np.where(
    df['close'] > df['kc_middle'],
    (df['close'] - df['kc_middle']) / (df['kc_upper'] - df['kc_middle']) * 100,
    (df['close'] - df['kc_middle']) / (df['kc_middle'] - df['kc_lower']) * 100
)

# Walk the bands
df['walking_upper'] = df['close'].rolling(5).min() > df['kc_upper'].rolling(5).mean()
df['walking_lower'] = df['close'].rolling(5).max() < df['kc_lower'].rolling(5).mean()

# Trading signals
df['long_signal'] = df['breakout_up'] | (df['squeeze_release'] & df['above_middle'])
df['short_signal'] = df['breakout_down'] | (df['squeeze_release'] & ~df['above_middle'])

print("Keltner Channel Analysis:")
print(df[['close', 'kc_upper', 'kc_middle', 'kc_lower', 'width_pct', 'breakout_up', 'squeeze']].tail(10))
  </code></pre>

  <h2 id="use-cases">Common Use Cases</h2>
  <h3>1. Trend Following Strategy</h3>
  <p>Trading with the trend using channel breaks:</p>
  <pre><code class="language-python">
# Calculate Keltner Channels
upper, middle, lower = keltner_channels(high, low, close, 20, 10, 2.0)

# Trend definition
uptrend = close > middle
downtrend = close < middle

# Entry signals
long_entry = (close > upper) & (close.shift(1) <= upper.shift(1)) & uptrend
short_entry = (close < lower) & (close.shift(1) >= lower.shift(1)) & downtrend

# Exit signals
long_exit = close < middle  # Exit when price crosses below middle
short_exit = close > middle  # Exit when price crosses above middle

# Position management
position = pd.Series(0, index=close.index)
for i in range(1, len(close)):
    if long_entry.iloc[i] and position.iloc[i-1] <= 0:
        position.iloc[i] = 1
    elif short_entry.iloc[i] and position.iloc[i-1] >= 0:
        position.iloc[i] = -1
    elif long_exit.iloc[i] and position.iloc[i-1] > 0:
        position.iloc[i] = 0
    elif short_exit.iloc[i] and position.iloc[i-1] < 0:
        position.iloc[i] = 0
    else:
        position.iloc[i] = position.iloc[i-1]

# Add filters
atr_value = atr(high, low, close, 10)
volatility_filter = atr_value > atr_value.rolling(50).median()
strong_trend = abs(close - middle) > 0.5 * (upper - middle)

filtered_long = long_entry & volatility_filter & strong_trend
filtered_short = short_entry & volatility_filter & strong_trend
  </code></pre>

  <h3>2. Mean Reversion Strategy</h3>
  <p>Trading returns to the middle band:</p>
  <pre><code class="language-python">
# Calculate Keltner Channels
upper, middle, lower = keltner_channels(high, low, close, 20, 10, 2.5)

# Extreme readings
extreme_high = close > upper
extreme_low = close < lower

# Mean reversion signals
# Buy when price touches lower band and turns up
reversion_buy = extreme_low & (close > low.shift(1)) & (close > close.shift(1))

# Sell when price touches upper band and turns down  
reversion_sell = extreme_high & (close < high.shift(1)) & (close < close.shift(1))

# Target: Middle band
long_target = middle
short_target = middle

# Stop: Beyond the bands
long_stop = lower - atr(high, low, close, 10) * 0.5
short_stop = upper + atr(high, low, close, 10) * 0.5

# Position sizing based on distance to target
distance_to_target_long = middle - close
distance_to_target_short = close - middle
risk_reward_long = distance_to_target_long / (close - long_stop)
risk_reward_short = distance_to_target_short / (short_stop - close)

# Only take trades with good risk/reward
valid_long = reversion_buy & (risk_reward_long > 2)
valid_short = reversion_sell & (risk_reward_short > 2)
  </code></pre>

  <h3>3. Squeeze Breakout Strategy</h3>
  <p>Trading volatility expansion after squeeze:</p>
  <pre><code class="language-python">
# Calculate Keltner Channels and Bollinger Bands
kc_upper, kc_middle, kc_lower = keltner_channels(high, low, close, 20, 10, 1.5)
bb_upper, bb_middle, bb_lower = bollinger_bands(close, 20, 2)

# Detect squeeze (BB inside KC)
squeeze = (bb_lower > kc_lower) & (bb_upper < kc_upper)
squeeze_off = ~squeeze & squeeze.shift(1)

# Momentum direction at squeeze release
momentum = close - close.shift(10)
momentum_up = momentum > 0
momentum_down = momentum < 0

# Breakout signals
squeeze_breakout_long = squeeze_off & momentum_up & (close > kc_middle)
squeeze_breakout_short = squeeze_off & momentum_down & (close < kc_middle)

# Channel expansion confirms breakout
channel_width = kc_upper - kc_lower
expanding_channel = channel_width > channel_width.shift(1)

confirmed_long = squeeze_breakout_long & expanding_channel
confirmed_short = squeeze_breakout_short & expanding_channel

# Trail stop using Keltner Channel
trailing_stop_long = kc_lower
trailing_stop_short = kc_upper

# Exit on momentum exhaustion
momentum_slowing = abs(momentum) < abs(momentum.shift(5))
exit_condition = momentum_slowing | (channel_width < channel_width.rolling(10).mean())
  </code></pre>

  <h2 id="edge-cases">Edge Cases & Errors</h2>
  <h3>Common Issues</h3>
  <ul>
    <li><strong>Whipsaws:</strong> Frequent channel touches in choppy markets</li>
    <li><strong>Lag:</strong> EMA-based channels lag during sharp moves</li>
    <li><strong>Parameter sensitivity:</strong> Wrong multiplier creates too many/few signals</li>
    <li><strong>Gap risk:</strong> Gaps can bypass channel levels entirely</li>
  </ul>

  <h3>Best Practices</h3>
  <ul>
    <li>Use ATR period of 10 regardless of EMA period for consistency</li>
    <li>Adjust multiplier based on market volatility and timeframe</li>
    <li>Confirm breakouts with volume or momentum indicators</li>
    <li>Use channel middle as trailing stop in strong trends</li>
    <li>Combine with squeeze indicators for volatility setups</li>
    <li>Monitor channel width for market regime changes</li>
  </ul>

  <h2 id="references">References</h2>
  <ul>
    <li>Keltner, C. (1960). "How to Make Money in Commodities"</li>
    <li>Raschke, L. B. & Connors, L. A. (1995). "Street Smarts: High Probability Short-Term Trading Strategies"</li>
    <li>Comparison of envelope indicators: Keltner vs Bollinger Bands vs Donchian</li>
    <li>ATR-based volatility bands in systematic trading</li>
  </ul>
</IndicatorLayout>