<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Optimizer Demo</title>
    <style>
      body { font-family: system-ui, Arial, sans-serif; margin: 20px; }
      #heatmap { border: 1px solid #ccc; image-rendering: pixelated; }
      .row { display: flex; gap: 20px; align-items: flex-start; }
      .col { display: flex; flex-direction: column; gap: 8px; }
      label { display: block; font-size: 12px; }
      input { width: 120px; }
    </style>
  </head>
  <body>
    <h1>ALMA Double-Crossover Optimizer Demo</h1>
    <div class="row">
      <div class="col">
        <label>Backend
          <select id="backend">
            <option value="cpu">CPU (fp64)</option>
            <option value="gpu">GPU (fp32)</option>
          </select>
        </label>
        <label>Series length <input id="len" type="number" value="50000" /></label>
        <label>Fast period (start,end,step) <input id="fast" value="5,240,5" /></label>
        <label>Slow period (start,end,step) <input id="slow" value="20,240,5" /></label>
        <label>Offset <input id="offset" type="number" step="0.01" value="0.85" /></label>
        <label>Sigma <input id="sigma" type="number" step="0.1" value="6.0" /></label>
        <label>Commission <input id="commission" type="number" step="0.0001" value="0.0" /></label>
        <button id="run">Run</button>
        <div id="status"></div>
      </div>
      <div class="col">
        <canvas id="heatmap" width="500" height="500"></canvas>
        <div id="legend"></div>
      </div>
      <div class="col">
        <div id="chart" style="width:640px;height:360px;border:1px solid #ccc"></div>
        <div id="selection" style="font-size:12px;color:#666"></div>
      </div>
    </div>

    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <script>
      async function post(url, body) {
        const res = await fetch(url, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
        return res.json();
      }
      function parseRange(s) { const [a,b,c] = s.split(',').map(x=>parseFloat(x)); return [a|0,b|0,c|0]; }
      function drawHeatmap(canvas, rows, cols, values, metricIndex) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        const img = ctx.createImageData(w, h);
        for (let y=0;y<h;y++) {
          const r = Math.floor(y * rows / h);
          for (let x=0;x<w;x++) {
            const c = Math.floor(x * cols / w);
            const base = (r*cols + c)*5;
            const v = values[base + metricIndex];
            const t = Math.max(0, Math.min(1, (v + 0.5)));
            const R = Math.floor(255 * t);
            const G = 0;
            const B = Math.floor(255 * (1 - t));
            const idx = (y*w + x)*4;
            img.data[idx+0]=R; img.data[idx+1]=G; img.data[idx+2]=B; img.data[idx+3]=255;
          }
        }
        ctx.putImageData(img, 0, 0);
      }
      // Trading chart setup
      const chartContainer = document.getElementById('chart');
      const chart = LightweightCharts.createChart(chartContainer, {
        layout: { background: { type: 'solid', color: '#ffffff' }, textColor: '#333' },
        rightPriceScale: { borderColor: '#ccc' },
        timeScale: { borderColor: '#ccc', timeVisible: true, secondsVisible: false },
      });
      const priceSeries = chart.addLineSeries({ color: '#888888', lineWidth: 1 });
      const fastSeries = chart.addLineSeries({ color: '#3b82f6', lineWidth: 2 });
      const slowSeries = chart.addLineSeries({ color: '#8b5cf6', lineWidth: 2 });

      function computeALMA(data, period, offset, sigma) {
        const out = new Array(data.length).fill(NaN);
        const m = offset * (period - 1);
        const s = period / sigma;
        const s2 = 2 * s * s;
        const w = new Array(period);
        let norm = 0;
        for (let i=0;i<period;i++){ const d=i - m; const wi = Math.exp(-(d*d)/s2); w[i]=wi; norm+=wi; }
        const inv = 1.0 / norm;
        // find first valid
        let first = 0; while (first < data.length && !isFinite(data[first])) first++;
        const warm = first + period - 1;
        for (let t = warm; t < data.length; t++) {
          let sum = 0; let start = t - period + 1; let valid=true;
          for (let k=0;k<period;k++){ const v = data[start+k]; if (!isFinite(v)) { valid=false; break; } sum += v * w[k]; }
          out[t] = valid ? sum * inv : NaN;
        }
        return out;
      }
      function backtestCrossover(prices, fast, slow, periodF, periodS, commission) {
        const first = prices.findIndex(v=>isFinite(v));
        const t0 = first + Math.max(periodF, periodS) - 1;
        let equity = 1.0, peak=1.0, maxdd=0.0; let trades=0; let pos=0;
        const markers=[];
        if (t0 < prices.length) { pos = fast[t0] > slow[t0] ? 1 : (fast[t0] < slow[t0] ? -1 : 0); }
        for (let t=t0+1; t<prices.length; t++){
          const fprev=fast[t-1], sprev=slow[t-1], fcur=fast[t], scur=slow[t];
          if (!isFinite(fprev)||!isFinite(sprev)||!isFinite(fcur)||!isFinite(scur)) continue;
          const sp = fprev>sprev?1:(fprev<sprev?-1:0); const sc = fcur>scur?1:(fcur<scur?-1:0);
          if (sc!==pos){
            if (pos===0 && sc!==0){ equity*=(1.0-commission); trades++; markers.push({ time: t, position: 'belowBar', color:'#22c55e', shape:'arrowUp', text:'BUY' }); pos=sc; }
            else if (pos!==0 && sc===0){ equity*=(1.0-commission); trades++; markers.push({ time: t, position: 'aboveBar', color:'#ef4444', shape:'arrowDown', text:'SELL' }); pos=0; }
            else if (pos!==0 && sc!==0){ equity*=(1.0-commission)*(1.0-commission); trades+=2; markers.push({ time: t, position: pos>0?'aboveBar':'belowBar', color: pos>0?'#ef4444':'#22c55e', shape: pos>0?'arrowDown':'arrowUp', text: pos>0?'SELL':'BUY' }); pos=sc; }
          }
          const r = prices[t]/prices[t-1]-1.0; const strat = pos===0?0:(pos*r);
          equity *= (1.0+strat); if (equity>peak) peak=equity; const dd = (peak>0)?(peak-equity)/peak:0; if (dd>maxdd) maxdd=dd;
        }
        return { equity: equity-1.0, maxdd, trades, markers };
      }

      let lastResult = null;

      async function runAndRender() {
        const backend = document.getElementById('backend').value;
        const len = parseInt(document.getElementById('len').value, 10);
        const fast = parseRange(document.getElementById('fast').value);
        const slow = parseRange(document.getElementById('slow').value);
        const offset = parseFloat(document.getElementById('offset').value);
        const sigma = parseFloat(document.getElementById('sigma').value);
        const commission = parseFloat(document.getElementById('commission').value);
        document.getElementById('status').textContent = 'Running...';
        const req = { backend, synthetic_len: len, series: null, fast_period: fast, slow_period: slow, offset, sigma, commission, metrics: 5 };
        const res = await post('/api/optimize', req);
        if (!res.ok) { document.getElementById('status').textContent = 'Error: ' + res.error; return; }
        lastResult = res.data;
        document.getElementById('status').textContent = 'Rows='+res.data.meta.rows+' Cols='+res.data.meta.cols;
        const canvas = document.getElementById('heatmap');
        drawHeatmap(canvas, res.data.meta.rows, res.data.meta.cols, res.data.values, 0);
        canvas.onclick = (ev)=>{
          const rect = canvas.getBoundingClientRect();
          const x = ev.clientX - rect.left; const y = ev.clientY - rect.top;
          const margin = { top: 40, right: 100, bottom: 60, left: 60 };
          const chartWidth = canvas.width - margin.left - margin.right;
          const chartHeight = canvas.height - margin.top - margin.bottom;
          const cellWidth = chartWidth / res.data.meta.fast_periods.length;
          const cellHeight = chartHeight / res.data.meta.slow_periods.length;
          if (x >= margin.left && x <= canvas.width - margin.right && y >= margin.top && y <= canvas.height - margin.bottom) {
            const col = Math.floor((x - margin.left) / cellWidth);
            const row = Math.floor((y - margin.top) / cellHeight);
            const fastP = res.data.meta.fast_periods[col];
            const slowP = res.data.meta.slow_periods[row];
            document.getElementById('selection').textContent = 'Selected fast='+fastP+' slow='+slowP;
            // Reconstruct synthetic series used (must match backend generator)
            const T = len; const series = new Array(T).fill(NaN);
            for (let i=3;i<T;i++){ const x=i; series[i] = Math.sin(x*0.001) + 0.0001*x; }
            const fastMA = computeALMA(series, fastP, offset, sigma);
            const slowMA = computeALMA(series, slowP, offset, sigma);
            const back = backtestCrossover(series, fastMA, slowMA, fastP, slowP, commission);
            // Build price data and MAs for chart (map index to time as seconds)
            const priceData = []; const fData=[]; const sData=[];
            const now = Math.floor(Date.now()/1000);
            for (let i=0;i<T;i++){
              const t = now - (T-i)*60; // 1-min spacing
              if (isFinite(series[i])) priceData.push({ time: t, value: series[i] });
              if (isFinite(fastMA[i])) fData.push({ time: t, value: fastMA[i] });
              if (isFinite(slowMA[i])) sData.push({ time: t, value: slowMA[i] });
            }
            priceSeries.setData(priceData);
            fastSeries.setData(fData);
            slowSeries.setData(sData);
            chart.timeScale().fitContent();
          }
        };
      }

      document.getElementById('run').onclick = runAndRender;
        const backend = document.getElementById('backend').value;
        const len = parseInt(document.getElementById('len').value, 10);
        const fast = parseRange(document.getElementById('fast').value);
        const slow = parseRange(document.getElementById('slow').value);
        const offset = parseFloat(document.getElementById('offset').value);
        const sigma = parseFloat(document.getElementById('sigma').value);
        const commission = parseFloat(document.getElementById('commission').value);
        document.getElementById('status').textContent = 'Running...';
        const req = { backend, synthetic_len: len, series: null, fast_period: fast, slow_period: slow, offset, sigma, commission, metrics: 5 };
        const res = await post('/api/optimize', req);
        if (!res.ok) { document.getElementById('status').textContent = 'Error: ' + res.error; return; }
        document.getElementById('status').textContent = 'Rows='+res.data.meta.rows+' Cols='+res.data.meta.cols;
        const canvas = document.getElementById('heatmap');
        drawHeatmap(canvas, res.data.meta.rows, res.data.meta.cols, res.data.values, 0);
      };
    </script>
  </body>
  </html>
